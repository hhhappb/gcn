# 文件名: precompute_hop_matrix.py
# 描述: 为多个骨架动作识别数据集一次性预计算跳数矩阵（Hop Matrix）。
# 使用Floyd-Warshall算法保证最短路径的准确性，并将结果生成为一个可直接导入的Python文件。

import torch
import numpy as np
import sys
import os

# --- 自动配置项目路径，确保可以顺利导入graph模块 ---
# 将此脚本所在的目录添加到Python搜索路径，以便于查找graph模块
# 无论您在哪里运行此脚本，它都能找到位于项目根目录下的graph文件夹
try:
    # 假设脚本在项目根目录
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))
except NameError:
    # 在某些交互式环境（如Jupyter）中，__file__未定义
    sys.path.append('.')

def compute_hop_matrix_floyd(adj_matrix, max_hop=12):
    """
    使用Floyd-Warshall算法计算跳数矩阵（所有节点对之间的最短路径）。
    这是计算该矩阵最权威、最准确的方法。

    参数:
        adj_matrix (torch.Tensor): 输入的邻接矩阵，代表物理连接。
                                 形状为 (V, V)，V是节点数。
        max_hop (int): 结果中允许的最大跳数，超过此值的距离将被截断。

    返回:
        torch.Tensor: 计算好的跳数矩阵，形状为 (V, V)，类型为 torch.long。
    """
    V = adj_matrix.shape[0]
    device = adj_matrix.device
    
    # 1. 初始化距离矩阵
    #    - 对角线（自己到自己）距离为0
    #    - 有物理连接的地方距离为1
    #    - 其他无直接连接的地方距离为无穷大
    hop_matrix = torch.full((V, V), float('inf'), dtype=torch.float, device=device)
    hop_matrix.fill_diagonal_(0)
    hop_matrix[adj_matrix > 0] = 1
    
    # 2. Floyd-Warshall算法核心：三重循环
    #    通过中转节点k，不断尝试更新i到j的最短距离
    for k in range(V):
        for i in range(V):
            for j in range(V):
                if hop_matrix[i, k] + hop_matrix[k, j] < hop_matrix[i, j]:
                    hop_matrix[i, j] = hop_matrix[i, k] + hop_matrix[k, j]
    
    # 3. 后处理
    #    - 将仍然为无穷大的距离（代表不连通）设置为max_hop
    #    - 转换为整数类型并返回
    hop_matrix[hop_matrix == float('inf')] = max_hop
    
    return hop_matrix.long().clamp(max=max_hop)

def precompute_all_datasets():
    """
    为所有目标数据集计算跳数矩阵。
    如果某个数据集的graph文件不存在，会打印错误信息并跳过。
    """
    print("🚀 开始为所有数据集预计算跳数矩阵...")
    print("-" * 50)
    
    datasets_to_compute = {
        'ntu_rgb_d': {'max_hop': 12, 'module_path': 'graph.ntu_rgb_d'},
        'nw-ucla': {'max_hop': 10, 'module_path': 'graph.ucla'},
        'shrec17': {'max_hop': 15, 'module_path': 'graph.shrec17'} 
    }
    
    results = {}
    
    for name, config in datasets_to_compute.items():
        print(f"🔄 正在处理数据集: {name}")
        try:
            # 动态导入Graph类
            module = __import__(config['module_path'], fromlist=['Graph'])
            Graph = module.Graph
            
            graph_instance = Graph()
            A = torch.from_numpy(graph_instance.A).float() # (K, V, V)
            
            # 使用内向+外向连接构建无向图
            physical_connections = (A[1] + A[2] > 0).float()
            
            # 计算跳数矩阵
            hop_matrix = compute_hop_matrix_floyd(physical_connections, max_hop=config['max_hop'])
            
            results[name] = {
                'hop_matrix': hop_matrix,
                'shape': hop_matrix.shape,
                'max_hop': hop_matrix.max().item(),
                'description': f'{name} with {hop_matrix.shape[0]} joints'
            }
            print(f"✅ 成功! | 形状: {hop_matrix.shape}, 最大跳数: {hop_matrix.max().item()}")
            
        except (ImportError, ModuleNotFoundError):
            print(f"❌ 失败! | 未找到模块: '{config['module_path']}'. 请确保文件存在。已跳过。")
        except Exception as e:
            print(f"❌ 失败! | 发生未知错误: {e}. 已跳过。")
        print("-" * 50)
            
    return results

def generate_code_file(results, filename='precomputed_hop_matrices.py'):
    """将计算结果生成为一个Python代码文件"""
    if not results:
        print("📝 未生成代码文件，因为没有任何数据集被成功处理。")
        return
        
    print(f"📝 正在生成代码文件: {filename}...")
    
    code_lines = [
        "# Auto-generated by precompute_hop_matrix.py.",
        "# This file contains precomputed hop matrices for various skeleton datasets.",
        "# DO NOT EDIT THIS FILE MANUALLY.",
        "",
        "import torch",
        "",
        "def get_precomputed_hop_matrix(dataset, device='cpu'):",
        "    \"\"\"Fetches the precomputed hop matrix for a given dataset.\"\"\"",
        ""
    ]
    
    first = True
    for dataset_name, data in results.items():
        hop_matrix = data['hop_matrix']
        statement = "if" if first else "elif"
        first = False
        
        code_lines.append(f"    {statement} dataset == '{dataset_name}':")
        code_lines.append(f"        # {data['description']}")
        code_lines.append(f"        # Shape: {data['shape']}, Max hop: {data['max_hop']}")
        
        hop_list = hop_matrix.cpu().numpy().tolist()
        code_lines.append("        hop_matrix = torch.tensor([")
        for row in hop_list:
            code_lines.append(f"            {row},")
        code_lines.append("        ], dtype=torch.long)")
        
    code_lines.append("    else:")
    code_lines.append("        supported = ', '.join(get_precomputed_hop_matrix.supported_datasets)")
    code_lines.append("        raise ValueError(f\"Hop matrix for dataset '{dataset}' not available. Supported datasets: [{supported}]\")")
    code_lines.append("")
    code_lines.append("    return hop_matrix.to(device)")
    code_lines.append("")
    code_lines.append("# Attach the list of supported datasets to the function for easy checking")
    code_lines.append(f"get_precomputed_hop_matrix.supported_datasets = {list(results.keys())}")

    
    with open(filename, 'w') as f:
        f.write("\n".join(code_lines))
    print(f"✅ 代码文件已成功保存到: {filename}")


def main():
    """主执行函数"""
    # 1. 为所有数据集计算跳数矩阵
    results = precompute_all_datasets()
    
    # 2. 生成包含这些矩阵的Python文件
    generate_code_file(results)
    
    print("\n🎉 预计算全部完成！")
    print("\n现在，你可以在你的主模型代码中这样使用它:")
    print("-----------------------------------------------------------------")
    print("from precomputed_hop_matrices import get_precomputed_hop_matrix")
    print("\n# 在模型__init__中:")
    print("hop_matrix = get_precomputed_hop_matrix('ntu_rgb_d', device=self.device)")
    print("self.register_buffer('hop_matrix', hop_matrix)")
    print("-----------------------------------------------------------------")


if __name__ == "__main__":
    main()