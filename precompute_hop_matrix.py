# æ–‡ä»¶å: precompute_hop_matrix.py
# æè¿°: ä¸ºå¤šä¸ªéª¨æ¶åŠ¨ä½œè¯†åˆ«æ•°æ®é›†ä¸€æ¬¡æ€§é¢„è®¡ç®—è·³æ•°çŸ©é˜µï¼ˆHop Matrixï¼‰ã€‚
# ä½¿ç”¨Floyd-Warshallç®—æ³•ä¿è¯æœ€çŸ­è·¯å¾„çš„å‡†ç¡®æ€§ï¼Œå¹¶å°†ç»“æœç”Ÿæˆä¸ºä¸€ä¸ªå¯ç›´æ¥å¯¼å…¥çš„Pythonæ–‡ä»¶ã€‚

import torch
import numpy as np
import sys
import os

# --- è‡ªåŠ¨é…ç½®é¡¹ç›®è·¯å¾„ï¼Œç¡®ä¿å¯ä»¥é¡ºåˆ©å¯¼å…¥graphæ¨¡å— ---
# å°†æ­¤è„šæœ¬æ‰€åœ¨çš„ç›®å½•æ·»åŠ åˆ°Pythonæœç´¢è·¯å¾„ï¼Œä»¥ä¾¿äºæŸ¥æ‰¾graphæ¨¡å—
# æ— è®ºæ‚¨åœ¨å“ªé‡Œè¿è¡Œæ­¤è„šæœ¬ï¼Œå®ƒéƒ½èƒ½æ‰¾åˆ°ä½äºé¡¹ç›®æ ¹ç›®å½•ä¸‹çš„graphæ–‡ä»¶å¤¹
try:
    # å‡è®¾è„šæœ¬åœ¨é¡¹ç›®æ ¹ç›®å½•
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))
except NameError:
    # åœ¨æŸäº›äº¤äº’å¼ç¯å¢ƒï¼ˆå¦‚Jupyterï¼‰ä¸­ï¼Œ__file__æœªå®šä¹‰
    sys.path.append('.')

def compute_hop_matrix_floyd(adj_matrix, max_hop=12):
    """
    ä½¿ç”¨Floyd-Warshallç®—æ³•è®¡ç®—è·³æ•°çŸ©é˜µï¼ˆæ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼‰ã€‚
    è¿™æ˜¯è®¡ç®—è¯¥çŸ©é˜µæœ€æƒå¨ã€æœ€å‡†ç¡®çš„æ–¹æ³•ã€‚

    å‚æ•°:
        adj_matrix (torch.Tensor): è¾“å…¥çš„é‚»æ¥çŸ©é˜µï¼Œä»£è¡¨ç‰©ç†è¿æ¥ã€‚
                                 å½¢çŠ¶ä¸º (V, V)ï¼ŒVæ˜¯èŠ‚ç‚¹æ•°ã€‚
        max_hop (int): ç»“æœä¸­å…è®¸çš„æœ€å¤§è·³æ•°ï¼Œè¶…è¿‡æ­¤å€¼çš„è·ç¦»å°†è¢«æˆªæ–­ã€‚

    è¿”å›:
        torch.Tensor: è®¡ç®—å¥½çš„è·³æ•°çŸ©é˜µï¼Œå½¢çŠ¶ä¸º (V, V)ï¼Œç±»å‹ä¸º torch.longã€‚
    """
    V = adj_matrix.shape[0]
    device = adj_matrix.device
    
    # 1. åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
    #    - å¯¹è§’çº¿ï¼ˆè‡ªå·±åˆ°è‡ªå·±ï¼‰è·ç¦»ä¸º0
    #    - æœ‰ç‰©ç†è¿æ¥çš„åœ°æ–¹è·ç¦»ä¸º1
    #    - å…¶ä»–æ— ç›´æ¥è¿æ¥çš„åœ°æ–¹è·ç¦»ä¸ºæ— ç©·å¤§
    hop_matrix = torch.full((V, V), float('inf'), dtype=torch.float, device=device)
    hop_matrix.fill_diagonal_(0)
    hop_matrix[adj_matrix > 0] = 1
    
    # 2. Floyd-Warshallç®—æ³•æ ¸å¿ƒï¼šä¸‰é‡å¾ªç¯
    #    é€šè¿‡ä¸­è½¬èŠ‚ç‚¹kï¼Œä¸æ–­å°è¯•æ›´æ–°iåˆ°jçš„æœ€çŸ­è·ç¦»
    for k in range(V):
        for i in range(V):
            for j in range(V):
                if hop_matrix[i, k] + hop_matrix[k, j] < hop_matrix[i, j]:
                    hop_matrix[i, j] = hop_matrix[i, k] + hop_matrix[k, j]
    
    # 3. åå¤„ç†
    #    - å°†ä»ç„¶ä¸ºæ— ç©·å¤§çš„è·ç¦»ï¼ˆä»£è¡¨ä¸è¿é€šï¼‰è®¾ç½®ä¸ºmax_hop
    #    - è½¬æ¢ä¸ºæ•´æ•°ç±»å‹å¹¶è¿”å›
    hop_matrix[hop_matrix == float('inf')] = max_hop
    
    return hop_matrix.long().clamp(max=max_hop)

def precompute_all_datasets():
    """
    ä¸ºæ‰€æœ‰ç›®æ ‡æ•°æ®é›†è®¡ç®—è·³æ•°çŸ©é˜µã€‚
    å¦‚æœæŸä¸ªæ•°æ®é›†çš„graphæ–‡ä»¶ä¸å­˜åœ¨ï¼Œä¼šæ‰“å°é”™è¯¯ä¿¡æ¯å¹¶è·³è¿‡ã€‚
    """
    print("ğŸš€ å¼€å§‹ä¸ºæ‰€æœ‰æ•°æ®é›†é¢„è®¡ç®—è·³æ•°çŸ©é˜µ...")
    print("-" * 50)
    
    datasets_to_compute = {
        'ntu_rgb_d': {'max_hop': 12, 'module_path': 'graph.ntu_rgb_d'},
        'nw-ucla': {'max_hop': 10, 'module_path': 'graph.ucla'},
        'shrec17': {'max_hop': 15, 'module_path': 'graph.shrec17'} 
    }
    
    results = {}
    
    for name, config in datasets_to_compute.items():
        print(f"ğŸ”„ æ­£åœ¨å¤„ç†æ•°æ®é›†: {name}")
        try:
            # åŠ¨æ€å¯¼å…¥Graphç±»
            module = __import__(config['module_path'], fromlist=['Graph'])
            Graph = module.Graph
            
            graph_instance = Graph()
            A = torch.from_numpy(graph_instance.A).float() # (K, V, V)
            
            # ä½¿ç”¨å†…å‘+å¤–å‘è¿æ¥æ„å»ºæ— å‘å›¾
            physical_connections = (A[1] + A[2] > 0).float()
            
            # è®¡ç®—è·³æ•°çŸ©é˜µ
            hop_matrix = compute_hop_matrix_floyd(physical_connections, max_hop=config['max_hop'])
            
            results[name] = {
                'hop_matrix': hop_matrix,
                'shape': hop_matrix.shape,
                'max_hop': hop_matrix.max().item(),
                'description': f'{name} with {hop_matrix.shape[0]} joints'
            }
            print(f"âœ… æˆåŠŸ! | å½¢çŠ¶: {hop_matrix.shape}, æœ€å¤§è·³æ•°: {hop_matrix.max().item()}")
            
        except (ImportError, ModuleNotFoundError):
            print(f"âŒ å¤±è´¥! | æœªæ‰¾åˆ°æ¨¡å—: '{config['module_path']}'. è¯·ç¡®ä¿æ–‡ä»¶å­˜åœ¨ã€‚å·²è·³è¿‡ã€‚")
        except Exception as e:
            print(f"âŒ å¤±è´¥! | å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}. å·²è·³è¿‡ã€‚")
        print("-" * 50)
            
    return results

def generate_code_file(results, filename='precomputed_hop_matrices.py'):
    """å°†è®¡ç®—ç»“æœç”Ÿæˆä¸ºä¸€ä¸ªPythonä»£ç æ–‡ä»¶"""
    if not results:
        print("ğŸ“ æœªç”Ÿæˆä»£ç æ–‡ä»¶ï¼Œå› ä¸ºæ²¡æœ‰ä»»ä½•æ•°æ®é›†è¢«æˆåŠŸå¤„ç†ã€‚")
        return
        
    print(f"ğŸ“ æ­£åœ¨ç”Ÿæˆä»£ç æ–‡ä»¶: {filename}...")
    
    code_lines = [
        "# Auto-generated by precompute_hop_matrix.py.",
        "# This file contains precomputed hop matrices for various skeleton datasets.",
        "# DO NOT EDIT THIS FILE MANUALLY.",
        "",
        "import torch",
        "",
        "def get_precomputed_hop_matrix(dataset, device='cpu'):",
        "    \"\"\"Fetches the precomputed hop matrix for a given dataset.\"\"\"",
        ""
    ]
    
    first = True
    for dataset_name, data in results.items():
        hop_matrix = data['hop_matrix']
        statement = "if" if first else "elif"
        first = False
        
        code_lines.append(f"    {statement} dataset == '{dataset_name}':")
        code_lines.append(f"        # {data['description']}")
        code_lines.append(f"        # Shape: {data['shape']}, Max hop: {data['max_hop']}")
        
        hop_list = hop_matrix.cpu().numpy().tolist()
        code_lines.append("        hop_matrix = torch.tensor([")
        for row in hop_list:
            code_lines.append(f"            {row},")
        code_lines.append("        ], dtype=torch.long)")
        
    code_lines.append("    else:")
    code_lines.append("        supported = ', '.join(get_precomputed_hop_matrix.supported_datasets)")
    code_lines.append("        raise ValueError(f\"Hop matrix for dataset '{dataset}' not available. Supported datasets: [{supported}]\")")
    code_lines.append("")
    code_lines.append("    return hop_matrix.to(device)")
    code_lines.append("")
    code_lines.append("# Attach the list of supported datasets to the function for easy checking")
    code_lines.append(f"get_precomputed_hop_matrix.supported_datasets = {list(results.keys())}")

    
    with open(filename, 'w') as f:
        f.write("\n".join(code_lines))
    print(f"âœ… ä»£ç æ–‡ä»¶å·²æˆåŠŸä¿å­˜åˆ°: {filename}")


def main():
    """ä¸»æ‰§è¡Œå‡½æ•°"""
    # 1. ä¸ºæ‰€æœ‰æ•°æ®é›†è®¡ç®—è·³æ•°çŸ©é˜µ
    results = precompute_all_datasets()
    
    # 2. ç”ŸæˆåŒ…å«è¿™äº›çŸ©é˜µçš„Pythonæ–‡ä»¶
    generate_code_file(results)
    
    print("\nğŸ‰ é¢„è®¡ç®—å…¨éƒ¨å®Œæˆï¼")
    print("\nç°åœ¨ï¼Œä½ å¯ä»¥åœ¨ä½ çš„ä¸»æ¨¡å‹ä»£ç ä¸­è¿™æ ·ä½¿ç”¨å®ƒ:")
    print("-----------------------------------------------------------------")
    print("from precomputed_hop_matrices import get_precomputed_hop_matrix")
    print("\n# åœ¨æ¨¡å‹__init__ä¸­:")
    print("hop_matrix = get_precomputed_hop_matrix('ntu_rgb_d', device=self.device)")
    print("self.register_buffer('hop_matrix', hop_matrix)")
    print("-----------------------------------------------------------------")


if __name__ == "__main__":
    main()